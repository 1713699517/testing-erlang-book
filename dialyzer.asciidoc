== Type Checking with Dialyzer

Unlike Haskell and other Members of the ML family, Erlang is not a
strictly typed language. There are a number of historical reasons for
this, mostly that when Erlang was being created that the people who
created it did not really understand how to build a Type System.

However there are some very nice tools for providing type
annoatiations and doing static type testing. These give some of the
benefit that a type system like haskell's without having to invest in
the full mechanism of Haskell's types.

The main tool for testing types is Daialyzer, which is a utility that
can check compiled code for type inconsistencies. This can be a
powerful way to check your code for all sorts of problems, in terms of
consistency of how functions are called. For Example, if you have some
parts of your application that treat string data as lists and other
parts that use binaries, dialyzer will find that for you.

Or to show an example from an application that I have worked on, we
had a function that was changed from having 4 arguments to 5. When we
put the code in production there was one place where we had not
converted it to the new signature. Had we run dialyzer on this we
would have caught it before deploying our code to production.

WARNING:  Dialyzer will hurt your feelings

=== Setting up Dialyzer to run the first time

In order to run dialyzer you need to create a Persistent Lookup
Table. This is a file that normally lives in your home directory (but
you can put it anywhere. This file contains basic information about
the type signatures of system applications 

To create a basic PLT file use a command line like this one. It will
take a few minutes to run and then create a plt file in the current
directory. If you omit the +--output_plt+ command then it will create
a plt file under a default name in your home directory. 

.Basic PLT File
[source,bash]
----
dialyzer  --build_plt --apps kernel stdlib mnesia inets ssl crypto \
	--output_plt project.plt
----

If you find that you have forgotten to add some applications to your
plt file then you can always add more applications to a PLT file with
a command like this. You can also add more than one application at a
time. 

.Add to PLT file
[source,bash]
----
dialyzer  --add_to_plt httpc  --output_plt project.plt
----

If your project, like mine, has a lot of dependences that you
have pulled of off github with rebar you can also add those to your
PLT file. I have a custom script that I use to run dialyzer that will
check if the plt file exists and if it does not will create it for
me. This script will pull all of the rebar dependencies, compile them
and build the plt file. 

[NOTE]
On my macbook air this takes 5 minutes to run or so. Its a good time
to get a cup of tea.


.build Project PLT
[source,bash]
----
PLT=api.plt
if [ ! -f $PLT ]; then
   rm -rf deps
   rebar clean
   rebar get-deps
   rebar compile
   
   dialyzer  --build_plt --apps kernel stdlib mnesia  inets ssl crypto \
       --output_plt $PLT
   apps=(deps/*/ebin)
   for app in "${apps[@]}"; do
       echo "Adding $app to PLT\n"
       dialyzer  --add_to_plt $app  --output_plt $PLT
   done
   echo "********************************************************************************"
   echo ""
fi
----

=== Running Dialyzer

Once the PLT file has been created then we can run dialyzer on the
code base. Normally dialyzer is run on the compile *beam* file but it
is also possible to run it on erlang source files.

To run the basic dialyzer on a source projects from the unix command
line use a command like this
.dialyzer
[source, bash]
------
dialyzer ebin --plt $PLT
-----

If you have more than one subdirectory of erlang applications then you
can run dialyzer on all of them at once. 


=== Understanding Errors 


=== Adding type annotations to functions

By default dialyzer will try to infer what types each function takes
as arguments and returns, however this often results in an overly
broad type signature that will accept things that it should not. 

As a developer Erlang gives us a way to fix this problem, we can tell
the compiler what types we think a function should be working
with. This also provides someone reading the code with some extra
information about the intent of the developer, which will be checked
by dialyzer. 

To add a type specification to a function use the +-spec()+
declaration as in this example. This tells dialyzer that the function
+known_content_type/2+ takes 2 arguments, a +wm_reqdata+ record and a
+payload+ record, and it returns a tuple consisting of a boolean, and
the same two record types. However unlike a comment this declaration
can be checked with dialyzer, so if the function changes, or a record
definition changes it will be caught. 

.Type Annotation
[source,erlang]
----
-spec(known_content_type(#wm_reqdata{}, #payload{}) -> {boolean(), #wm_reqdata{}, #payload{}}).
known_content_type(ReqData, Context) ->
    ContentType = wrq:get_req_header("content-type", ReqData),
    Values = [{undefined,				true},
	      {"application/json",			true},
	      {"application/json; charset=UTF-8",	true}],
    Allowed = proplists:get_value(ContentType, Values, false),
    {Allowed, ReqData, Context}.
----    

Most erlang abstract types are written in a way that they look like
functions. So, for example, the type integer is +integer()+ and a
boolean is +boolean()+.

In addition to abstract types there are also literal types, these are
often atoms or numbers that represent themselves. So for example the
atom +'ok'+ is a literal type that will match itself, or the number
+42+ is also a literal type.

Types can also be combined with a vertical bar to make more complex
type. So the type +number()+ is defined as +integer() | float()+. You
could also define a new type as +'ok'|'error'+ which might be the
value returned by a function.

Erlang has a number of predefined types, and they can be found in the
Erlang reference manual
(http://www.erlang.org/doc/reference_manual/typespec.html). These
cover all of the basic types you would expect, such as +integer()+,
+binary()+, +iolist()+, +atom()+ and so on.


A record can also be used as its own type with the syntax
+#RecordName{}+. When defining a record it is often a good idea to
define types for each field in the record as shown in this
example. Here we have a user record with three fields, all of which
have a type of +binary()+ as they are string fields, however the
+avatar+ field could also be blank.

[source, erlang]
----
-record(user, {
	  user_id			:: binary(),
	  email                         :: binary(),
	  avatar = none                 :: binary() | none
}).

----

We could make that declaration more expressive 

=== Adding Type annotations to records

=== Creating your own types
 


