== PropER

Property based testing is a field of testing that represents a major
improvement over unit testing in many ways. While a unit test will try
one or two possible inputs to a function to ensure that it is doing
the correct thing, a property based testing system will use a set of
rules to apply hundreds or thousands of inputs to a system to ensure
that they all act correctly. 

The problem from the developer's point of view is that this is as this
is a newer form of testing we the programming community may not be as
familar with it and may not understand how and when to best apply it
to get optimal results. 

Furthermore the two main tools (QuickCheck and PropER) both suffer
from a lack of documentation and examples of how to build these
tests for our code

=== What is PropER

NOTE: Like Dialyzer, PropER is a product of the research group of
Kostis Sagonas at Uppsala University and NTUA.


PropER is a testing framework that uses a model to create random
inputs and make sure that the results make sense. The idea is that a
unit test may try a few possible inputs with PropER you can make
hundreds of tests that will hopefully expose any strange corner cases.

However there is an art of how to do this. You need to find a way to
test the code such that you are not testing it against itself. If you
say +f(A) =:= f(A)+ then you probably have not learned very much from
your tests

This can work very well for some types of code but is more difficult
for others, This chapter will explore how I applied PropER to the
+tiny_pq+ library which is used by Chicago Boss s part of its TinyMQ.

TinyMQ has a tree structure in which each element looks like this,
where the keys are integers and the values are a possible list. We
want to generate an initial starting state and then apply an operation
to it and validate the end result. For example one possible operation
is to change the priority of an item. In this case we want to verify
that after we do it that it does not exist in the list for the old
priority but does exist for the new one.

.DataStructure
[source,erlang]
----
3 -> [ 5, 9, 11]
----

=== Installing PropER

=== Setting up basic tests


=== Using types to drive tests


=== How many Tests to run
Property based tests work on the principle that we will create a
number of random tests and ensure that they all pass your model. The
question is how many tests to run, too few and we won't find as many
bugs, too many and the tests will take too long to run. So how to find
the optimal number of tests. 


One valid option is to run a smaller number as part of your CI build,
and then run a larger number of tests as part of a nightly build. 

TODO Research this more

=== Running our properties

We may wish to run a property based test from the erlang REPL. by calling
+proper:quickcheck(my_prop())+ This is good for explratory testing and
the like. However you may also wish to run your property based tests
is part of a larger test suite. The easist way to do that is to wrap
it in an eunit assertion like this.

[source, erlang]
=====
delete_test() ->
    ?assert(proper:quickcheck(delete_prop(), [{to_file,user}])).

=====

A few things to note, first of all function +proper:quickcheck/2+ will
return true if everything passed so the eunit +?assert+ macro will
run the property.Seconly you will note the option of +{to_file,user}+
this is because eunit will capture output of the tests. By passing the
option we get around this.
       78
The other issue is that both proper and eunit define a macro
+?LET+. To ensure that the proper version of this macro is used
include proper before eunit, or you could just have the PropER and
EUnit tests in seperate modules.

=== A basic property

Suppose that we have a function that removes an element from a list
(Yes there is one in the library, its an example), as in this
example. And let us assume all of the elements are integers, just to
keep things simple. Then we would like to assert that given an element
and a list if we apply the function to the list then the resulting
element might would not have that element in it. 

If we used a classical unit test we might setup test cases like this:

[source,erlang]
----
remove_from_list_test() ->
    ?assertEqual([], remove_from_list(3,[3])),
    ?assertEqual([1], remove_from_list(2,[1,2])),
    ?assertEqual([1], remove_from_list(2,[2])).                        

----

And we might assume that we have covered all the cases. However there
is a bug in this code, in that if it will not do the right thing if an
element is duplicated, in that case it will only remove the first
instance of that element. 

.remove_from_list.erl
----
include:proper/remove_from_list.erl
----

We can test this with the property shown above, the function
_prop_not_in_list/0_ states for an integer, El, and a list of
integers, List, that El will be removed from the list by the function
remove_from_list/2. 

This will then generate a lot of random values until it can find a
counter example. When I ran the property It came up with this counter
example: 

.counter example
----
{2,[-53,39,2,11,6,72,2,-6,-10,-24,0,-14,-14,-13,18,17,31,15,71,-6,10]}
----

However this example has more than 20 elements in the list (and there
is no reason why it could not have had 250 or more). So the exact
problem might be hard to find. As such PropER will attempt to shrink
the counter example to the most simplified form it can find. In this
case after shrinking it found the example of _{0, [0,0]}_ which is
expresses the idea that a duplicate item is what is exposing the bug.  

.counter example after shrinking
----
{0,[0,0]}
----
